from pyglet.gl import *
import enum
from copy import *

size = 800

class PieceType(enum.Enum):
    king = 0
    queen = 1
    bishop = 2
    knight = 3
    rook = 4
    pawn = 5

class PlayerType(enum.Enum):
    black = 0
    white = 1

class Piece():
    def __init__(self, _rank, _team, _posx, _posy):
        self.rank = _rank
        self.team = _team
        self.x = _posx
        self.y = _posy
        self.en_passant = False

class GameWindow(pyglet.window.Window):

    color1 = (0xFF,0xDC,0x69,0xFF)
    color2 = (0x6D,0x29,0x00,0xFF)
    hovercolor = (0xFF,0xFF,0xFF,0x4D)
    movecolor = (0x73,0xC4,0x2B,0x4D)
    selcolor = (0xE6,0x6A,0x12,0x4D)
    
    hoverpos_x=-1
    hoverpos_y=-1

    selpos_x=-1
    selpos_y=-1

    selpiece_index=-1

    legal_moves = []

    opponent_moves = []

    castle_flags = 0b1111
    
    #for chessboard bg
    tile1 = pyglet.image.create(
            size//8,
            size//8,
            pyglet.image.SolidColorImagePattern(color1))
    tile2 = pyglet.image.create(
            size//8,
            size//8,
            pyglet.image.SolidColorImagePattern(color2))

    #input/selection visuals
    hovertile = pyglet.image.create(
            size//8,
            size//8,
            pyglet.image.SolidColorImagePattern(hovercolor))

    seltile = pyglet.image.create(
            size//8,
            size//8,
            pyglet.image.SolidColorImagePattern(selcolor))

    movetile = pyglet.image.create(
            size//8,
            size//8,
            pyglet.image.SolidColorImagePattern(movecolor))

    #piece assets
    pieceset = pyglet.image.load("Pieces.png")

    piece_names = ['K','Q','B','R','N','']

    black = []
    white = []

    #container for piece objects
    pieces = []
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        #generate pieces
        for i in range(8):
            #we can generate pawns iteratively with relative ease
            self.pieces.append(Piece(PieceType.pawn,PlayerType.black,i,6))
            self.pieces.append(Piece(PieceType.pawn,PlayerType.white,i,1))

        #Other pieces are generated by brute force with hard coded initial positions
        #There may be a better way to do this, but the runtime/writetime tradeoff
        #is very skewed in favor of this ugly solution
        self.pieces.append(Piece(PieceType.rook,PlayerType.black,0,7))
        self.pieces.append(Piece(PieceType.rook,PlayerType.black,7,7))
        self.pieces.append(Piece(PieceType.rook,PlayerType.white,0,0))
        self.pieces.append(Piece(PieceType.rook,PlayerType.white,7,0))
        self.pieces.append(Piece(PieceType.knight,PlayerType.black,1,7))
        self.pieces.append(Piece(PieceType.knight,PlayerType.black,6,7))
        self.pieces.append(Piece(PieceType.knight,PlayerType.white,1,0))
        self.pieces.append(Piece(PieceType.knight,PlayerType.white,6,0))
        self.pieces.append(Piece(PieceType.bishop,PlayerType.black,2,7))
        self.pieces.append(Piece(PieceType.bishop,PlayerType.black,5,7))
        self.pieces.append(Piece(PieceType.bishop,PlayerType.white,2,0))
        self.pieces.append(Piece(PieceType.bishop,PlayerType.white,5,0))
        self.pieces.append(Piece(PieceType.queen,PlayerType.black,3,7))
        self.pieces.append(Piece(PieceType.king,PlayerType.black,4,7))
        self.pieces.append(Piece(PieceType.queen,PlayerType.white,3,0))
        self.pieces.append(Piece(PieceType.king,PlayerType.white,4,0))

        #All the pieces are on one image. We can use subimaging to access
        #them individually. The indices are made to align with the PieceType
        #enumerations
        for i in range(6):
            self.white.append(
                self.pieceset.get_region(
                    i*self.pieceset.width//6,
                    self.pieceset.height//2,
                    self.pieceset.width//6,
                    self.pieceset.height//2))
            self.black.append(
                self.pieceset.get_region(
                    i*self.pieceset.width//6,
                    0,
                    self.pieceset.width//6,
                    self.pieceset.height//2))
        self.current_player = PlayerType.white
        
    def on_draw(self):
        window.clear()

        #I need this to display accurate alpha values
        glEnable(GL_BLEND)
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
        
        for i in range(8):
            for j in range(4):
                self.tile1.blit(size//8*(2*j+1-(i%2)),size//8*i)
                self.tile2.blit(size//8*(2*j+(i%2)),size//8*i)

        if self.selpos_x>=0 and self.selpos_y>=0:
            self.seltile.blit(size//8*self.selpos_x,size//8*self.selpos_y)

        for (x,y) in self.legal_moves:
            self.movetile.blit(size//8*x,size//8*y)
        #for (x,y) in self.opponent_moves:
        #   self.movetile.blit(size//8*x,size//8*y)

        for piece in self.pieces:
            if piece.team == PlayerType.black:
                self.black[piece.rank.value].blit(
                    size//8*piece.x,
                    size//8*piece.y)
            else:
                self.white[piece.rank.value].blit(
                    size//8*piece.x,
                    size//8*piece.y)
        if self.hoverpos_x>=0 and self.hoverpos_y>=0:
            self.hovertile.blit(size//8*self.hoverpos_x,size//8*self.hoverpos_y)

    def on_mouse_motion(self, x, y, dx, dy):
        self.hoverpos_x = x//(size//8)
        self.hoverpos_y = y//(size//8)
        pass

    def get_pawn_moves(self, x, y):
        self.legal_moves.append((x,y+2*self.current_player.value-1))
        if y == 6 - 5*self.current_player.value:
            self.legal_moves.append((x,y+4*self.current_player.value-2))
        for other in self.pieces:
            if len(self.legal_moves) >0 and (other.x, other.y) == self.legal_moves[0]:
                self.legal_moves = []
            elif len(self.legal_moves) == 2 and (other.x, other.y) == self.legal_moves[1]:
                self.legal_moves.pop(1)
        for other in self.pieces:
            if other.y == y+2*self.current_player.value-1 and abs(x-other.x)==1:
                self.legal_moves.append((other.x,other.y))
            elif other.y == y and abs(x-other.x)==1 and other.en_passant:
                self.legal_moves.append((other.x,y+2*self.current_player.value-1))

    def get_knight_moves(self, x, y):
        self.legal_moves.append((x+1,y+2))
        self.legal_moves.append((x-1,y+2))
        self.legal_moves.append((x+1,y-2))
        self.legal_moves.append((x-1,y-2))
        self.legal_moves.append((x+2,y+1))
        self.legal_moves.append((x+2,y-1))
        self.legal_moves.append((x-2,y+1))
        self.legal_moves.append((x-2,y-1))

    def get_bishop_moves(self, x, y):
        for i in range(4):
            for j in range(1,8):
                pos = (x+j*(1-2*(i>1)),y+j*(1-2*(i%2)))
                if pos[0]>=0 and pos[0]<8 and pos[1]>=0 and pos[1]<8:
                    self.legal_moves.append(pos)
                exit_flag = False
                if self.legal_moves:
                    for other in self.pieces:
                        if (other.x,other.y) == self.legal_moves[-1]:
                            exit_flag = True
                            break
                if exit_flag:
                    break

    def get_rook_moves(self, x, y):
        for i in range(4):
            for j in range(1,8):
                pos = (x+j*(0 if i%2 else i-1),y+j*(i-2 if i%2 else 0))
                if pos[0]>=0 and pos[0]<8 and pos[1]>=0 and pos[1]<8:
                    self.legal_moves.append(pos)
                exit_flag = False
                if self.legal_moves:
                    for other in self.pieces:
                        if (other.x,other.y) == self.legal_moves[-1]:
                            exit_flag = True
                            break
                if exit_flag:
                    break

    def get_queen_moves(self, x, y):
        self.get_bishop_moves(x,y)
        self.get_rook_moves(x,y)

    def get_king_moves(self, x, y):
        self.legal_moves.append((x+1,y+1))
        self.legal_moves.append((x-1,y+1))
        self.legal_moves.append((x+1,y-1))
        self.legal_moves.append((x-1,y-1))
        self.legal_moves.append((x,y+1))
        self.legal_moves.append((x,y-1))
        self.legal_moves.append((x-1,y))
        self.legal_moves.append((x+1,y))

    def get_castle(self):
        if self.current_player == PlayerType.black:
            if self.castle_flags & 0b1000 and (3,7) in self.legal_moves:
                temp_flag = True
                for other_piece in self.pieces:
                    if (other_piece.x,other_piece.y) == (2,7):
                        temp_flag = False
                        break
                if temp_flag:
                    self.legal_moves.append((2,7))
            if self.castle_flags & 0b0100 and (5,7) in self.legal_moves:
                temp_flag = True
                for other_piece in self.pieces:
                    if (other_piece.x,other_piece.y) == (6,7):
                        temp_flag = False
                        break
                if temp_flag:
                    self.legal_moves.append((6,7))
        else:
            if self.castle_flags & 0b0010 and (3,0) in self.legal_moves:
                temp_flag = True
                for other_piece in self.pieces:
                    if (other_piece.x,other_piece.y) == (2,0):
                        temp_flag = False
                        break
                if temp_flag:
                    self.legal_moves.append((2,0))
            if self.castle_flags & 0b0001 and (5,0) in self.legal_moves:
                temp_flag = True
                for other_piece in self.pieces:
                    if (other_piece.x,other_piece.y) == (6,0):
                        temp_flag = False
                        break
                if temp_flag:
                    self.legal_moves.append((6,0))

    def get_opponent_moves2(self):
        temp = deepcopy(self.legal_moves)
        for piece in self.pieces:
            if piece.team == self.current_player:
                if piece.rank == PieceType.pawn:
                    self.get_pawn_moves(piece.x,piece.y)
                elif piece.rank == PieceType.knight:
                    self.get_knight_moves(piece.x,piece.y)
                elif piece.rank == PieceType.bishop:
                    self.get_bishop_moves(piece.x,piece.y)
                elif piece.rank == PieceType.rook:
                    self.get_rook_moves(piece.x,piece.y)
                elif piece.rank == PieceType.queen:
                    self.get_queen_moves(piece.x,piece.y)
                else:
                    self.get_king_moves(piece.x,piece.y)

                #blocking code
                for other_piece in self.pieces:
                    if other_piece.team == self.current_player:
                        for j in range(len(self.legal_moves)):
                            if self.legal_moves[j] == (other_piece.x,other_piece.y):
                                self.legal_moves.pop(j)
                                break

                #self check prevention
                for j in range(len(self.legal_moves)):
                    temp_board = deepcopy(self.pieces)
                    temp_state = deepcopy(self.current_player)
                    temp_moves = deepcopy(self.legal_moves)
                    check_flag = False
                    self.select_move(temp_moves[j][0],temp_moves[j][1])
                    #check test
                    self.get_opponent_moves()
                    for pos in self.opponent_moves:
                        for piece in self.pieces:
                            if piece.rank == PieceType.king and piece.team == temp_state and pos == (piece.x,piece.y):
                                check_flag = True
                    if check_flag:
                        temp_moves[j] = (-1,-1)
                    else:
                        print(temp_moves[j])
                        self.pieces = temp_board
                        self.current_player = temp_state
                        self.opponent_moves = temp_moves
                        self.legal_moves = temp
                        return
                    self.pieces = temp_board
                    self.current_player = temp_state
                    self.legal_moves = temp
        self.opponent_moves = temp_moves
        self.legal_moves = temp

    def get_opponent_moves(self):
        temp = deepcopy(self.legal_moves)
        for piece in self.pieces:
            if piece.team == self.current_player:
                if piece.rank == PieceType.pawn:
                    self.get_pawn_moves(piece.x,piece.y)
                elif piece.rank == PieceType.knight:
                    self.get_knight_moves(piece.x,piece.y)
                elif piece.rank == PieceType.bishop:
                    self.get_bishop_moves(piece.x,piece.y)
                elif piece.rank == PieceType.rook:
                    self.get_rook_moves(piece.x,piece.y)
                elif piece.rank == PieceType.queen:
                    self.get_queen_moves(piece.x,piece.y)
                else:
                    self.get_king_moves(piece.x,piece.y)

                #blocking code
                for other_piece in self.pieces:
                    if other_piece.team == self.current_player:
                        for j in range(len(self.legal_moves)):
                            if self.legal_moves[j] == (other_piece.x,other_piece.y):
                                self.legal_moves.pop(j)
                                break

        self.opponent_moves = deepcopy(self.legal_moves)
        self.legal_moves = temp

    def select_move(self, x, y, real = False):
        if real:
            print(self.piece_names[self.pieces[self.selpiece_index].rank.value], end ='')
        #castling enable/disable
        if self.pieces[self.selpiece_index].rank == PieceType.king:
            if self.current_player==PlayerType.black:
                self.castle_flags = self.castle_flags & 0b0011
            else:
                self.castle_flags = self.castle_flags & 0b1100
        elif self.pieces[self.selpiece_index].rank == PieceType.rook:
            pos = (self.pieces[self.selpiece_index].x,self.pieces[self.selpiece_index].y)
            if pos == (0,7):
                self.castle_flags = self.castle_flags & 0b0111
            elif pos == (7,7):
                self.castle_flags = self.castle_flags & 0b1011
            elif pos == (0,0):
                self.castle_flags = self.castle_flags & 0b1101
            elif pos == (7,0):
                self.castle_flags = self.castle_flags & 0b1110
        #castling
        if self.pieces[self.selpiece_index].rank == PieceType.king:
            if abs(x-self.pieces[self.selpiece_index].x) == 2:
                for i in range(len(self.pieces)):
                    if self.pieces[i].rank == PieceType.rook and self.pieces[i].team == self.current_player:
                        if x-self.pieces[self.selpiece_index].x == 2 and self.pieces[i].x == 7:
                            self.pieces[i].x = 5
                        elif x-self.pieces[self.selpiece_index].x == -2 and self.pieces[i].x == 0:
                            self.pieces[i].x = 3
        #capture code
        capture_flag = False
        for i in range(len(self.pieces)):
            if i != self.selpiece_index and (x,y) == (self.pieces[i].x,self.pieces[i].y):
                if real:
                    capture_flag = True
                    print('x'+chr(ord('A')+x)+str(y+1), end = ' ')
                self.pieces[i].x=-1
                self.pieces[i].y=-1

                self.selpos_x = -1
                self.selpos_y = -1
                self.legal_moves = []
            elif self.pieces[i].en_passant:
                if self.pieces[self.selpiece_index].rank == PieceType.pawn and abs(self.pieces[self.selpiece_index].x-x) == 1:
                    if real:
                        capture_flag = True
                        print('x'+chr(ord('A')+x)+str(y+1)+' e.p ', end = '')
                    if self.pieces[i].x == x and abs(y-self.pieces[i].y)==1:
                        self.pieces[i].x=-1
                        self.pieces[i].y=-1

                        self.selpos_x = -1
                        self.selpos_y = -1
                        self.legal_moves = []
        if real and not capture_flag:
            print(chr(ord('A')+x)+str(y+1), end = ' ')
        if real and self.current_player == PlayerType.black:
            print('\n', end = '')
        if self.pieces[self.selpiece_index].rank == PieceType.pawn and abs(y-self.pieces[self.selpiece_index].y) == 2:
            self.pieces[self.selpiece_index].en_passant = True
        self.pieces[self.selpiece_index].x = x
        self.pieces[self.selpiece_index].y = y

        if self.current_player == PlayerType.black:
            self.current_player = PlayerType.white
        else:
            self.current_player = PlayerType.black
        self.legal_moves = []

    def on_mouse_press(self, x, y, button, modifiers):
        valid_sel = False
        #piece selection
        for i in range(len(self.pieces)):
            #reset all en passant flags
            if self.pieces[i].team == self.current_player and self.pieces[i].en_passant:
                self.pieces[i].en_passant = False
            #determine legal moves for selected piece
            if (self.pieces[i].x,self.pieces[i].y) == (self.hoverpos_x,self.hoverpos_y):
                if self.pieces[i].team == self.current_player:
                    valid_sel = True
                    self.selpos_x = self.hoverpos_x
                    self.selpos_y = self.hoverpos_y
                    self.selpiece_index = i
                    self.legal_moves = []
                    if self.pieces[i].rank == PieceType.pawn:
                        self.get_pawn_moves(self.pieces[i].x, self.pieces[i].y)
                    elif self.pieces[i].rank == PieceType.knight:
                        self.get_knight_moves(self.pieces[i].x, self.pieces[i].y)
                    elif self.pieces[i].rank == PieceType.bishop:
                        self.get_bishop_moves(self.pieces[i].x, self.pieces[i].y)
                    elif self.pieces[i].rank == PieceType.rook:
                        self.get_rook_moves(self.pieces[i].x, self.pieces[i].y)
                    elif self.pieces[i].rank == PieceType.queen:
                        self.get_queen_moves(self.pieces[i].x, self.pieces[i].y)
                    else:
                        self.get_king_moves(self.pieces[i].x, self.pieces[i].y)

                    #blocking code
                    for other_piece in self.pieces:
                        if other_piece.team == self.current_player:
                            for j in range(len(self.legal_moves)):
                                if self.legal_moves[j] == (other_piece.x,other_piece.y):
                                    self.legal_moves.pop(j)
                                    break
                    if self.pieces[i].rank == PieceType.king:
                        self.get_castle()

                    #self check prevention
                    for j in range(len(self.legal_moves)):
                        temp_board = deepcopy(self.pieces)
                        temp_state = deepcopy(self.current_player)
                        temp_moves = deepcopy(self.legal_moves)
                        check_flag = False
                        self.select_move(temp_moves[j][0],temp_moves[j][1])
                        #check test
                        self.get_opponent_moves()
                        for pos in self.opponent_moves:
                            for piece in self.pieces:
                                if piece.rank == PieceType.king and piece.team == temp_state and pos == (piece.x,piece.y):
                                    check_flag = True
                        if check_flag:
                            temp_moves[j] = (-1,-1)
                        self.pieces = temp_board
                        self.current_player = temp_state
                        self.legal_moves = temp_moves
                            

        #move selection
        for (x,y) in self.legal_moves:
            if (x,y) == (self.hoverpos_x,self.hoverpos_y):
                self.select_move(x,y, True)

                if self.current_player == PlayerType.black:
                    self.current_player = PlayerType.white
                else:
                    self.current_player = PlayerType.black

                checkflag = False
                self.get_opponent_moves()
                for pos in self.opponent_moves:
                    for piece in self.pieces:
                        if piece.rank == PieceType.king and pos == (piece.x,piece.y):
                            checkflag = True

                if self.current_player == PlayerType.black:
                    self.current_player = PlayerType.white
                else:
                    self.current_player = PlayerType.black
                self.legal_moves = []

                
                checkmate_flag = checkflag
                if checkflag:
                    self.opponent_moves = []
                    self.get_opponent_moves2()
                    for pos in self.opponent_moves:
                        if pos != (-1,-1):
                            checkmate_flag = False
                if checkmate_flag:
                    print("checkmate")
                elif checkflag:
                    print("check")
                break
        if not valid_sel:
            self.selpos_x = -1
            self.selpos_y = -1
            self.selpiece_index = -1
            self.legal_moves = []
        pass

    def on_mouse_leave(self, x, y):
        self.hoverpos_x = -1
        self.hoverpos_y = -1
        pass
    
if __name__ == "__main__":
    window = GameWindow(size, size,"Chess")
    pyglet.app.run()
